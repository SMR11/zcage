#!/usr/bin/env node --abort_on_uncaught_exception

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2018, Carlos Neira cneirabustos@gmail.com .All rights reserved.
 */


const zone = require('./lib/zonelib');
const img = require('./lib/imageadm');
const commandLineArgs = require('command-line-args');
const commandLineUsage = require('command-line-usage');
var os = require('os');

const ZCAGE_VERSION = '1.4.2';

let mainDefinitions = [{
    name: 'name',
    defaultOption: true
}];
const mainCommand = commandLineArgs(mainDefinitions, {
    stopAtFirstUnknown: true
});
let argv = mainCommand._unknown || [];

if ((os.type() != 'SunOS')) {
    console.log(
        'Kid, get yerself a System  https://wiki.illumos.org/display/illumos/Distributions'
    );
    return null;
}

switch (mainCommand.name) {

case "create":
    const createDefinitions = [
	{
            name: 'alias'
	},
	{
	    name: 'brand',
	    defaultValue: "sparse"
	},
	{
	    name: 'net'
	},
	{
	    name: 'autoboot',
	    type: Boolean
	},
	{
	    name: "ram",
	    defaultValue: '1gb'
	},
	{
	    name: "with-image"
	},
	{
	    name: "fs-allowed"
	},
	{
	    name: "limitpriv"
	},
	{
	    name: "disk"
	},
	{
	    name: "hostbridge"
	},
	{
	    name: "cpu"
	},
	{
	    name: "quota"
	},
	{
	    name: "cdrom"
	},
 	{
	    name: "debug",
	    defaultValue: false, 
	    type: Boolean
	},

    ];
    const createOptions = commandLineArgs(createDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = createOptions._unknown || [];

    if (createOptions.net == undefined) {
	help();
	return;
    }
    if (img.Isactivated() == 0) {
        zone.build(createOptions);
    }

    break;

case "destroy":
    const destroyDefinitions = [{
        name: 'zonename',
        alias: 'z'
    }];
    const destroyOptions = commandLineArgs(destroyDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = destroyOptions._unknown || [];

    if ("zonename" in destroyOptions && (destroyOptions.zonename != null)) {
        zone.destroy(destroyOptions.zonename);
    } else {
        console.log("need zone name to destroy");
    }
    break;

case "list":
    const listDefinitions = [{
        name: 'state',
    }];
    const listOptions = commandLineArgs(listDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });

    argv = listOptions._unknown || [];

    zone.listzones(listOptions);
    break;

case "start":

    const startDefinitions = [
	{
            name: 'zonename',
            alias: 'z'
	},
	{
	    name: 'with-iso'
	}
    ];
    const startOptions = commandLineArgs(startDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = startOptions._unknown || [];

    if ((startOptions.zonename != null ) && ("zonename" in startOptions) && !("with-iso" in startOptions)) {
        zone.start(startOptions.zonename);
    } else if ( (startOptions.zonename != null ) && ("zonename" in startOptions) && ("with-iso" in startOptions)){
        zone.start(startOptions.zonename, startOptions['with-iso']);
    }else {
        console.log("need zone alias or uuid to start");
    }
    break;

case "stop":

    const stopDefinitions = [{
        name: 'zonename',
        alias: 'z'
    }];
    const stopOptions = commandLineArgs(stopDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = stopOptions._unknown || [];

    if ("zonename" in stopOptions && (stopOptions.zonename != null)) {
        zone.halt(stopOptions.zonename);
    } else {
        console.log("need zone alias or uuid to stop");
    }
    break;

case "reboot":

    const rebootDefinitions = [{
        name: 'zonename',
        alias: 'z'
    }];
    const rebootOptions = commandLineArgs(rebootDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = rebootOptions._unknown || [];

    if (("zonename" in rebootOptions) && (rebootOptions.zonename != null)) {
        zone.reboot(rebootOptions.zonename);
    } else {
        console.log("need zone alias or uuid to reboot");
    }
    break;


case "update":

    const rctlDefinitions = [
	{
            name: 'zonename',
            alias: 'z'
	},
	{
	    name: "ram"
	},
	{
	    name: "cpu-shares"
	},
	{
	    name: "dedicated-cpu"
	},
	{
	    name: "dedicated-cpu-importance"
	},
	{
	    name: "max-lwps"
	},
	{
	    name: "autoboot",
	    type: Boolean
	},
	{
	    name: "quota"
	}
    ];
    const rctlOptions = commandLineArgs(rctlDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = rctlOptions._unknown || [];

    if ("zonename" in rctlOptions && (rctlOptions.zonename != null)) {
        zone.rctl(rctlOptions.zonename, rctlOptions);
    } else {
        console.log("need zone alias or uuid  to update");
    }
    break;

case "info":

    const getDefinitions = [{
        name: 'zonename',
        alias: 'z'
    }];
    const getOptions = commandLineArgs(getDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = getOptions._unknown || [];

    if ("zonename" in getOptions && (getOptions.zonename != null)) {
        zone.getzonedata(getOptions.zonename);
    } else {
        console.log("missing zone alias or uuid ");
    }
    break;


case "version":
    console.log(ZCAGE_VERSION);
    break;

case "activate":
    if (img.Isactivated() != 0) {
        img.ActivateZcage();
    } else {
        console.log("zcage is already activated, you should be able to create zones.");
    }
    break;

case "images":
    const listimgDefinitions = [
	{
            name: 'os'
	},
	{
	    name: 'version'
	},
	{
	    name: 'name'
	},
	{
	    name: 'uuid'
	},
	{
	    name: 'list',
	    alias: 'l'
	}
    ];
    const listimgOptions = commandLineArgs(listimgDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = listimgOptions._unknown || [];

    if (img.Isactivated() == 0) {
        if (listimgOptions.list) {
            switch (listimgOptions.list) {
            case 'local':
                img.list_avail();
                break;

            case 'remote':
                img.list_images();
                break;
            }
        } else {
            console.log(
                "you need to specify to list remote or local images --list local | remote"
            );
        }
    }
    break;


case "pull":
    const pullDefinitions = [{
        name: 'image'
    }];
    const pullOptions = commandLineArgs(pullDefinitions, {
        argv,
        stopAtFirstUnknown: true
    });
    argv = pullOptions._unknown || [];

    if (img.Isactivated() == 0) {
        if (pullOptions.image)
            img.getzss(pullOptions.image);
        else
            console.log("specify image to pull --image uuid ");
    } else {
        console.log(
            "zcage must be activated to be able to pull images : zcage activate "
        );
    }
    break;

default:
    if(mainCommand.name) 
	console.log("zcage:\n unknown subcommand '" + mainCommand.name  + "'");
    help();
}

function help() {
    console.log('Available commands are:\n\nversion: Returns current version of zcage\n\ncreate:\n\n\tsubcommands:\n\n' + 
	        '\t--net:   Configures network for container format is nic|ip/mask|gateway.\n\n' +
		'\t--ram : Assigns maximum RAM memory allowed for the zone.\n\n' +
		'\t--with-image:  use image uuuid when creating the container (needed for lx brand)\n\n' +
		'\t--autoboot: This container will be started when host is booted by default the value false.\n\n' +
		'destroy:\n\n\t-z <container name or UUID>:  Destroys a container (cannot be undone)' +
		'\n\nstart:\n\n\tsubcommands:\n\n\t-z <container name or UUID>:  Starts the container\n\n\t' + '-with-iso: starts zone using iso image (bhyve only)\n\n' +
		'stop:\n\n\t-z <container name or UUID>: Stops the running container\n\n' +
		'info:\n\n\t-z <container name or UUID>: Returns information for the container.\n\n' +
		'pull:\n\n\tsubcommands:\n\n\t--image <uuid> :  Retrieves image using uuid and stores for later usage.\n\n\n' +
		'images:\n\n\tsubcommands:\n\n\t--list  avail|local : Displays current available images in remote host or locally available for container creation\n\n\n\n' +
		'Examples:\n\nTo create a vm with 2gb of ram using with ip address/mask 192.168.1.225/24 and gateway 192.168.1.1\n\n' +
		'zcage create --net "vnic0|192.168.1.225/24|192.168.1.1" --ram 2gb');

}
