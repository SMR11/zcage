/* zcage tries to perform the same tasks as iocage but for illumos
 * http://iocage.readthedocs.io/en/latest/basic-use.html#activate-iocage
 * command syntax will be like iocage
 * TODO:
 * - Improve Error to reflect the actual error from the zoneadm and zonecfg tools
 * - Improve function naming to reflect actual purpose.
 * - Add Unit tests and coverage
 */

const ip = require('ipaddr.js');
const chalk = require('chalk');
const {
    spawnSync
} = require('child_process');


function mapToObj(inputMap) {
    let obj = {};

    inputMap.forEach(function(value, key) {
        obj[key] = value
    });
    return obj;
}

function ZonesString() {
    var zoneadm = spawnSync('zoneadm', ['list', '-cp']);
    var zones = zoneadm.stdout.toString().split('\n');
    zones.pop();
    return zones;
}

function Zonedata(zonestring) {
    var values = zonestring.toString().split(':');
    var keys = ["zoneid", "zonename", "state", "zone-path", "uuid", "brand", "ip-type"];
    var m = new Map();
    values.pop();
    for (var i = 0, len = values.length; i < len; i++) {
        m.set(keys[i], values[i]);
    }
    return mapToObj(m);
}

function list() {
    var zones = ZonesString();
    var zone_data;
    var zoneobjs = [];

    for (var i = 0, len = zones.length; i < len; i++) {
        zoneobjs.push(Zonedata(zones[i]));
    }
    return zoneobjs;

}

function listzones(listOptions) {
    var zones = ZonesString();
    var zone_data;
    var zoneobjs = [];

    for (var i = 0, len = zones.length; i < len; i++) {
	    z = Zonedata(zones[i]);
	    
	    if ("state" in listOptions ) {
		    if (listOptions["state"] == z.state)
			    zoneobjs.push(z);
	    } else {
		    if ("configured" != z.state ) {
			    switch (z.state) { 
			    case "installed" :
					z.state = "stopped";	
					break;
		      	   }
			    zoneobjs.push(z);
			}
	    }
    }
    console.log("UUID\t\t\t\t\tSTATE\t\tTAG");
    for (var i = 0, len = zoneobjs.length; i < len; i++) {
        if (zoneobjs[i].zonename != "global")
            console.log(zoneobjs[i].uuid, "  ", zoneobjs[i].state, "     ", zoneobjs[i].zonename);
    }
}


function getdata(zonename) {
    var zones = list();
    var zone = zones.filter(function(e) {
        return e.zonename == zonename;
    });
    if (zone == undefined)
        return null;
    return zone[0];
}

function addmeta(zoneobj) {
    if (zoneobj.state == "running") {
        var zname = zoneobj.zonename;
        zoneobj.hostname = exec(zname, "hostname");
        if (zoneobj.brand == "lx") {
            zoneobj.usedmem_percentage = exec(zname,
                "free | grep Mem | awk '{print $3/$2 * 100.0}'");
            zoneobj.freemem_percentage = ExecZonecmd(zname,
                "free | grep Mem | awk '{print $4/$2 * 100.0}'");
        }
    }
}

function destroy(zonename) {
    var z = getdata(zonename);
    var zdestroy;

    if (z == null) {
        console.log("Error: zone does not exists");
        return null;
    }
    if (z.state == "running") {
        var zhalt = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
        if (zhalt.err != null) {
            console.log("Error halting zone ", zhalt.stderr.toString());
            return zhalt.status;
        }
    }

    zdestroy = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall', '-F']);
    if (zdestroy.err != null) {
        console.log("Error uninstalling : ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    zdestroy = spawnSync('pfexec', ['zonecfg', '-z', zonename, 'delete', '-F']);
    if (zdestroy.err != null) {
        console.log("Error deleting: ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    return zdestroy.status;
}

function getinfo(zonename) {
    var zonecfg = spawnSync('zonecfg', ['-z', zonename, 'info']);
    if (zonecfg.err != null)
        console.log("info ", zonecfg.stderr.toString());
    return zonecfg.stdout.toString();
}

function exec(zonename, cmd) {
    var zlogin = spawnSync('pfexec', ['zlogin', zonename, cmd]);

    if (zlogin.err != null)
        console.log("err \n", zlogin.stderr.toString());

    return zlogin.status;
}

function start(zonename) {

    var zone = getdata(zonename);
    if (zone == null) {
        console.log("Error : alias does not exists");
        return null;
    }
 
    var start = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'boot']);
    if (start.error != null)
        console.log("error starting region");
    return start.status;
}

function halt(zonename) {
    var stop = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
    if (stop.error != null)
        console.log("info ", stop.stdout.toString());

    return stop.stdout.toString();
}

function reboot(zonename) {
    var reboot = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'reboot']);
    if (reboot.error != null)
        console.log("info ", reboot.stdout.toString());

    return reboot.status;
}


function install(zonename) {
    var iz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'install']);
    if (iz.error != null)
        console.log("Error installing ", iz.stderr.toString());
    return iz.status;
}

function uninstall(zonename) {
    var uz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall']);
    if (uz.error != null)
        console.log("Error uninstalling ", uz.stderr.toString());

    return uz.status;
}

function addattr(zonename, zoneobj, attr) {
    var cmd, attr;
    if ("brand" in zoneobj) {
        cmd = 'add attr; set name=' + attr.name + ';' +
            'set type=' + attr.type + ';'
        'set value=' + attr.value + ';' + 'end';
        attr = spawnSync('zonecfg', ['-z', zonename, cmd]);
        if (attr.error != null)
            console.log("Error adding attribute:", attr.stderr.toString());
        return attr.status;
    } else {
        console.log("Error zoneobj does not have brand property");
        return null;
    }
}

function create(zonename, zone_spec) {
    var script = spec2script(zonename, zone_spec);
    var status = -1;
    if (script != null) {
        var zonecfg = spawnSync('pfexec', ['zonecfg', '-z', zonename, script]);
        status = install(zonename);
        if (status != 0) {
            console.log("Error: Installing zone");
        }
        status = setupzone(zonename, zone_spec);
        if (status != 0) {
            console.log("Zone postsetup failed= ", status);
            return status;
        }
    }
    return status;
}

function setupzone(zonename, zone_spec) {
    var status = -1;
    switch (zone_spec.brand) {
        case "sparse":
            start(zonename);
            var setup = genpostscript(zone_spec);
            var status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            while (status != 0) {
                status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            }

            status = exec(zonename, setup);
            if (status != 0)
                console.log("Error exec setting up zone", setup);
            status = halt(zonename);
            if (status != 0)
                console.log("Error halting setting up zone", setup);
            break;

        default:
            break;
    }
    return status;
}


function create_zone_spec(resources) {
    var spec = {
        zonepath: "",
        brand: "",
        'ip-type': "exclusive",
        'dns-domain': "",
        resolvers: ["8.8.8.8", "8.8.8.4"],
    };
    if (resources != null && ("net", "brand" in resources)) {
        Object.keys(resources).forEach(function(key) {
            spec[key] = resources[key];
        });
    }
    return spec;
}

function spec2script(zname, spec) {
    var script = "";
    var zone = getdata(zname);
    if (zone != null) {
        console.log("Error : alias already exists");
        return null;
    }
    if ("brand", "net" in spec) {
        script = "create;"
        Object.keys(spec).forEach(function(key) {
            switch (key) {
                case "net":
                    spec.net.forEach(function(e) {
                        script +=
                            " add net ;";
                        if (spec.brand == "lx")
                            Object.keys(e).forEach(function(key) {
                                script += " set " + key + "=" + e[key] + ";";
                            });
                        else
                            script += " set physical=" + e["physical"] + ";";
                        script += " end;"
                    });
                    break;

                case "resolvers":
                case "dns-domain":
                    break;
                default:
                    script += " set " + key + "=" + spec[key] + ";";
                    break;
            }
        });
        script += "verify; commit;";
    } else {
        console.log("error not a valid spec");
        return null;
    }
    return script
}

/*
 * This is needed to setup networking in sparse zones
 *  # zoneadm -z omni boot
 *  # zlogin omni
 *  # ipadm create-if omni0
 *  # ipadm create-addr -T static -a local=x.x.x.x/y omni0/v4
 *  # echo x.x.x.x > /etc/defaultrouter
 *  # echo nameserver 80.80.80.80 > /etc/resolv.conf
 *  # cp /etc/nsswitch.{dns,conf}
 *  # svcadm restart routing-setup
 */

function genpostscript(zone_spec) {
    var postshellcmd = "";
    switch (zone_spec.brand) {
        case "sparse":
            postshellcmd = "sleep 1; "
            zone_spec.net.forEach(function(e) {
                Object.keys(e).forEach(function(key) {
                    if (key == "physical") {
                        postshellcmd += "ipadm create-if " + e["physical"] + " && ";
                    }
                    if (key == "address") {
                        postshellcmd +=
                            "ipadm create-addr -T static -a local=" +
                            e["address"] +
                            " " +
                            e["physical"] + "/v4 && ";

                    }
                    if (key == "gateway") {
                        postshellcmd += " echo " + e[key] + " >> /etc/defaultrouter &&";
                    }
                });
            });

            var resolvers = zone_spec.resolvers.toString().split(",");
            for (var i = 0, len = resolvers.length; i < len; i++) {
                postshellcmd += " echo nameserver " + resolvers[i] + " >> /etc/resolv.conf &&";
            }
            postshellcmd += " cp /etc/nsswitch.{dns,conf} && svcadm restart routing-setup ";
            break;

        default:
            postshellcmd = null;
    }
    return postshellcmd;
}
/*
 *  Parses --ipaddr="vnic0|192.168.1.1/24|gateway,.."
 *  to a network json tag
 */
function ipaddrcmd2netobject(ipaddr) {
    var networks = ipaddr.split(",");
    var net = [];
    for (var i = 0, l = networks.length; i < l; i++) {
        var o = {};
        addrnic = networks[i].split("|");
        if (addrnic.length < 3) {
            console.log('Error not enough parameters in --net\n example : --net="vnic|vm-ipaddress|vm-gateway-ipaddress');
        }
        o["physical"] = addrnic[0];
        var address = addrnic[1].split("/");
        o["address"] = address[0];
        if (ip.parse(o["address"]).kind() == "ipv4") {
            o["netmask"] = ip.IPv4.subnetMaskFromPrefixLength(address[1]).toString();
        } else {
            o["netmask"] = ip.IPv6.subnetMaskFromPrefixLength(address[1]).toString();
        }
        o["gateway"] = addrnic[2];
        net.push(o);
    }
    //console.log("network is ", net);
    return net;
}
// minimal zonespec
//var o = {
//    brand: "sparse",
//    autoboot: "false",
//    zonepath: "/zones/test01",
//    net: [{
//        physical: "vnic0",
//        gateway: "192.168.1.1",
//        ips: ["192.168.1.108"],
//    }],
//};

function build(createOptions) {
        if ("net" in createOptions) {
            var zname;
            createOptions["net"] =
                ipaddrcmd2netobject(createOptions["net"]);
            if ("alias" in createOptions) {
                zname = createOptions["alias"];
                delete createOptions["alias"];
            } else {
                zname = uuidv4();
            }
            createOptions["zonepath"] = `/zones/${zname}`;
            var count = createOptions["count"];
            delete createOptions["count"];
            var z = create_zone_spec(createOptions);
            if (create(zname, z) == 0) {
                console.log("created vm : ", zname);
            }
        } else {
            console.log('Error missing --net=nic|ipaddr');
        }
}

module.exports.destroy = destroy;
module.exports.create = create;
module.exports.halt = halt;
module.exports.start = start;
module.exports.listzones = listzones;
module.exports.build = build;
module.exports.create_zone_spec = create_zone_spec;
module.exports.ipaddrcmd2netobject = ipaddrcmd2netobject;
