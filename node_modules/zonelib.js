/* zcage tries to perform the same tasks as iocage but for illumos
 * http://iocage.readthedocs.io/en/latest/basic-use.html#activate-iocage
 * command syntax will be like iocage
 * TODO:
 * - Improve Error to reflect the actual error from the zoneadm and zonecfg tools
 * - Improve function naming to reflect actual purpose.
 * - Add Unit tests and coverage
 */

const ip = require('ipaddr.js');
const {
    spawnSync
} = require('child_process');


function mapToObj(inputMap) {
    let obj = {};

    inputMap.forEach(function(value, key) {
        obj[key] = value
    });
    return obj;
}

function ZonesString() {
    var zoneadm = spawnSync('zoneadm', ['list', '-cp']);
    var zones = zoneadm.stdout.toString().split('\n');
    zones.pop();
    return zones;
}

function Zonedata(zonestring) {
    var values = zonestring.toString().split(':');
    var keys = ["zoneid", "zonename", "state", "zone-path", "uuid", "brand", "ip-type"];
    var m = new Map();
    values.pop();
    for (var i = 0, len = values.length; i < len; i++) {
        m.set(keys[i], values[i]);
    }
    return mapToObj(m);
}

function list() {
    var zones = ZonesString();
    var zone_data;
    var zoneobjs = [];

    for (var i = 0, len = zones.length; i < len; i++) {
        zoneobjs.push(Zonedata(zones[i]));
    }
    return zoneobjs;
}

function getdata(zonename) {
    var zones = list();
    var zone = zones.filter(function(e) {
        return e.zonename == zonename;
    });
    if (zone == undefined)
        return null;
    return zone[0];
}

function addmeta(zoneobj) {
    if (zoneobj.state == "running") {
        var zname = zoneobj.zonename;
        zoneobj.hostname = exec(zname, "hostname");
        if (zoneobj.brand == "lx") {
            zoneobj.usedmem_percentage = exec(zname,
                "free | grep Mem | awk '{print $3/$2 * 100.0}'");
            zoneobj.freemem_percentage = ExecZonecmd(zname,
                "free | grep Mem | awk '{print $4/$2 * 100.0}'");
        }
    }
}

function destroy(zonename) {
    var z = getdata(zonename);
    var zdestroy;

    if (z == null) {
        console.log("Error: zone does not exists");
        return null;
    }
    if (z.state == "running") {
        var zhalt = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
        if (zhalt.err != null) {
            console.log("Error halting zone ", zhalt.stderr.toString());
            return zhalt.status;
        }
    }

    zdestroy = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall', '-F']);
    if (zdestroy.err != null) {
        console.log("Error uninstalling : ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    zdestroy = spawnSync('pfexec', ['zonecfg', '-z', zonename, 'delete', '-F']);
    if (zdestroy.err != null) {
        console.log("Error deleting: ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    return zdestroy.status;
}

function getinfo(zonename) {
    var zonecfg = spawnSync('zonecfg', ['-z', zonename, 'info']);
    console.log("info ", zonecfg.stdout.toString());
    return zonecfg.status;
}

function exec(zonename, cmd) {
    var zlogin = spawnSync('pfexec', ['zlogin', zonename, cmd]);

    if (zlogin.err != null)
        console.log("err \n", zlogin.stderr.toString());
    return zlogin.status;
}

function start(zonename) {
    var start = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'boot']);
    if (start.error != null)
        console.log("error starting region");

    return start.status;
}

function halt(zonename) {
    var stop = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
    if (stop.error != null)
        console.log("info ", stop.stdout.toString());

    return stop.stdout.toString();
}

function reboot(zonename) {
    var reboot = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'reboot']);
    if (reboot.error != null)
        console.log("info ", reboot.stdout.toString());

    return reboot.status;
}

function setproperty(zonename, property) {
    var zonedata = GetZoneData(zonename);
    var key = Object(property.keys());
    var val = Object(property.values());
    zonedata[key] = val;
    return zonedata;
}

function getproperty(zonename, property) {
    var zonedata = GetZoneData(zonename);
    var key = property.keys();
    return zonedata[key]
}

function install(zonename) {
    var iz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'install']);
    if (iz.error != null)
        console.log("installing ", iz.stderr.toString());
    return iz.status;
}

function uninstall(zonename) {
    var uz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall']);
    if (uz.error != null)
        console.log("uninstalling ", uz.stderr.toString());

    return uz.status;
}

function addattr(zonename, zoneobj, attr) {
    var cmd, attr;
    if ("brand" in zoneobj) {
        cmd = 'add attr; set name=' + attr.name + ';' +
            'set type=' + attr.type + ';'
        'set value=' + attr.value + ';' + 'end';
        attr = spawnSync('zonecfg', ['-z', zonename, cmd]);
        if (attr.error != null)
            console.log("Error adding attribute:", attr.stderr.toString());
        return attr.status;
    } else {
        console.log("Error zoneobj does not have brand property");
        return null;
    }
}

function create(zonename, zone_spec) {
    var script = spec2script(zonename, zone_spec);
    var status = -1;
    if (script != null) {
        var zonecfg = spawnSync('pfexec', ['zonecfg', '-z', zonename, script]);
        console.log("creating ", zonecfg.stderr.toString());
        status = install(zonename);
        if (status != 0) {
            console.log("Error starting zone for postsetup");
        }
        status = setupzone(zonename, zone_spec);
        if (status != 0) {
            console.log("Zone postsetup failed= ", status);
        }
        return status;
    }
    return status;
}

function setupzone(zonename, zone_spec) {
    var status = -1;
    switch (zone_spec.brand) {
        case "sparse":
            start(zonename);
            var setup = genpostscript(zone_spec);
            var status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            while (status != 0) {
                status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            }
            status = exec(zonename, setup);
            status = halt(zonename);
            break;

        default:
            break;
    }
    return status;
}


function create_zone_spec(resources) {
    var spec = {
        zonepath: "",
        brand: "",
        'ip-type': "exclusive",
        'dns-domain': "",
        resolvers: ["8.8.8.8", "8.8.8.4"],
    };
    if (resources != null && ("net", "brand" in resources)) {
        Object.keys(resources).forEach(function(key) {
            spec[key] = resources[key];
        });
    }
    console.log("props", JSON.stringify(spec, null, 4));
    return spec;
}

function spec2script(zname, spec) {
    var script = "";
    var zone = getdata(zname);
    if (zone != null) {
        console.log("Error : zone name already exists");
        return null;
    }
    if ("brand", "net" in spec) {
        script = "create;"
        Object.keys(spec).forEach(function(key) {
            switch (key) {
                case "net":
                    spec.net.forEach(function(e) {
                        script +=
                            " add net ;";
                        if (spec.brand == "lx")
                            Object.keys(e).forEach(function(key) {
                                script += " set " + key + "=" + e[key] + ";";
                            });
                        else
                            script += " set physical=" + e["physical"] + ";";
                        script += " end;"
                    });
                    break;

                case "resolvers":
                case "dns-domain":
                    break;
                default:
                    script += " set " + key + "=" + spec[key] + ";";
                    break;
            }
        });
        script += "verify; commit;";
    } else {
        console.log("error not a valid spec");
        return null;
    }
    console.log("script", script);
    return script
}

/*
 * This is needed to setup networking in sparse zones
 *  # zoneadm -z omni boot
 *  # zlogin omni
 *  # ipadm create-if omni0
 *  # ipadm create-addr -T static -a local=x.x.x.x/y omni0/v4
 *  # echo x.x.x.x > /etc/defaultrouter
 *  # echo nameserver 80.80.80.80 > /etc/resolv.conf
 *  # cp /etc/nsswitch.{dns,conf}
 *  # svcadm restart routing-setup
 */

function genpostscript(zone_spec) {
    var postshellcmd = "";
    switch (zone_spec.brand) {
        case "sparse":
            postshellcmd = "sleep 1; "
            zone_spec.net.forEach(function(e) {
                Object.keys(e).forEach(function(key) {
                    if (key == "physical") {
                        postshellcmd += "ipadm create-if " + e["physical"] + " && ";
                    }
                    if (key == "ips") {
                        var ips = e[key].toString().split(",");
                        for (var i = 0, len = ips.length; i < len; i++) {
                            postshellcmd +=
                                "ipadm create-addr -T static -a local=" +
                                ips[i] +
                                " " +
                                e["physical"] + "/v4 && ";
                        }
                    }
                    if (key == "gateway") {
                        postshellcmd += " echo " + e[key] + " >> /etc/defaultrouter &&";
                    }
                });
            });

            var resolvers = zone_spec.resolvers.toString().split(",");
            for (var i = 0, len = resolvers.length; i < len; i++) {
                postshellcmd += " echo nameserver " + resolvers[i] + " >> /etc/resolv.conf &&";
            }
            postshellcmd += " cp /etc/nsswitch.{dns,conf} && svcadm restart routing-setup ";
            break;

        default:
            postshellcmd = null;
    }
    console.log("shell ", postshellcmd);
    return postshellcmd;
}
/*
 *  Parses --ipaddr="vnic0|192.168.1.1/24"
 *  to a network json tag
 */
function ipaddrcmd2netobject(ipaddr) {
	var networks = ipaddr.split(",");
	var net = [] ;
    	for (var i = 0, l = networks.length; i < l; i++) {
		var o = {};
		addrnic = networks[i].split("|");
		o["physical"] = addrnic[0];
		var address =  addrnic[1].split("/");
		o["address"] = address[0];
		o["ip-version"] = ip.parse(o["address"]).kind();
		if ( o["ip-version"] == "ipv4" ) {
		   o["gateway"] = ip.IPv4.subnetMaskFromPrefixLength(address[1]).toString();
		} else {
		   o["gateway"] = ip.IPv6.subnetMaskFromPrefixLength(address[1]).toString();
		}
		net.push(o);
	}
	console.log("network is ", net);
	return networks;
}


module.exports.destroy = destroy;
module.exports.create  = create;
module.exports.halt    = halt;
module.exports.start   = start;
module.exports.list   =  list ;
module.exports.create_zone_spec = create_zone_spec;
module.exports.ipaddrcmd2netobject= ipaddrcmd2netobject;

