/* zcage tries to perform the same tasks as iocage but for illumos
 * http://iocage.readthedocs.io/en/latest/basic-use.html#activate-iocage
 * command syntax will be like iocage
 * TODO:
 * - Improve Error to reflect the actual error from the zoneadm and zonecfg tools
 * - Improve function naming to reflect actual purpose.
 * - Add Unit tests and coverage
 */

const ip = require('ipaddr.js');
const chalk = require('chalk');
const bytes = require('bytes');
const {
    spawnSync
} = require('child_process');


function mapToObj(inputMap) {
    let obj = {};

    inputMap.forEach(function(value, key) {
        obj[key] = value
    });
    return obj;
}

function ZonesString() {
    var zoneadm = spawnSync('zoneadm', ['list', '-cp']);
    var zones = zoneadm.stdout.toString().split('\n');
    zones.pop();
    return zones;
}

function Zonedata(zonestring) {
    var values = zonestring.toString().split(':');
    var keys = ["zoneid", "zonename", "state", "zone-path", "uuid", "brand", "ip-type"];
    var m = new Map();
    values.pop();
    for (var i = 0, len = values.length; i < len; i++) {
        m.set(keys[i], values[i]);
    }
    return mapToObj(m);
}

function list() {
    var zones = ZonesString();
    var zone_data;
    var zoneobjs = [];

    for (var i = 0, len = zones.length; i < len; i++) {
        zoneobjs.push(Zonedata(zones[i]));
    }
    return zoneobjs;

}

function listzones(listOptions) {
    var zones = ZonesString();
    var zone_data;
    var zoneobjs = [];
    var type;

    for (var i = 0, len = zones.length; i < len; i++) {
	    z = Zonedata(zones[i]);
	    
	    if ("state" in listOptions ) {
		    if (listOptions["state"] == z.state)
			    zoneobjs.push(z);
	    } else {
		    if ("configured" != z.state ) {
			    switch (z.state) { 
			    case "installed" :
					z.state = "stopped";	
					break;
		      	   }
			    zoneobjs.push(z);
			}
	    }
    }
    console.log("UUID\t\t\t\t\tTYPE\t\tSTATE\t\tRAM\t\tALIAS");
    for (var i = 0, len = zoneobjs.length; i < len; i++) {
        if (zoneobjs[i].zonename != "global") {
		if ( zoneobjs[i].state == "running") {	
		    if (zoneobjs[i].brand != "lx")
		       type = "OS"
		    else 
			type = "LX" 
	            console.log(chalk`${zoneobjs[i].uuid}   ${type}\t\t{green.bold ${zoneobjs[i].state}}\t\t${zoneobjs[i].zonename}`);
		    
		} else 
	            console.log(chalk`${zoneobjs[i].uuid}   ${type}\t\t{red.bold ${zoneobjs[i].state}}\t\t${zoneobjs[i].zonename}`);
       }
    }
}

function getdata(zonename, uuid ) {
    var zones = list();
    var zone = zones.filter(function(e) {
	if (uuid != undefined) 
		return e.uuid = uuid;
	else 
	        return e.zonename == zonename;
    });
    if (zone == undefined)
        return null;
    return zone[0];
}

function addmeta(zoneobj) {
    if (zoneobj.state == "running") {
        var zname = zoneobj.zonename;
        zoneobj.hostname = exec(zname, "hostname");
        if (zoneobj.brand == "lx") {
            zoneobj.usedmem_percentage = exec(zname,
                "free | grep Mem | awk '{print $3/$2 * 100.0}'");
            zoneobj.freemem_percentage = exec(zname,
                "free | grep Mem | awk '{print $4/$2 * 100.0}'");
        }else {
		 out = {};
		 exec(zname, "uptime", out);
	         zoneobj["uptime"] = out["uptime"].split("  ")[2];
	     }
    }
}

function destroy(zonename) {
    var z = getdata(zonename);
    var zdestroy;

    if (z == null) {
        console.log("Error: zone does not exists");
        return null;
    }
    if (z.state == "running") {
        var zhalt = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
        if (zhalt.err != null) {
            console.log("Error halting zone ", zhalt.stderr.toString());
            return zhalt.status;
        }
    }

    zdestroy = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall', '-F']);
    if (zdestroy.err != null) {
        console.log("Error uninstalling : ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    zdestroy = spawnSync('pfexec', ['zonecfg', '-z', zonename, 'delete', '-F']);
    if (zdestroy.err != null) {
        console.log("Error deleting: ", zdestroy.stderr.toString());
        return zdestroy.status;
    }

    return zdestroy.status;
}

function getinfo(zonename) {
    var zonecfg = spawnSync('zonecfg', ['-z', zonename, 'info']);
    if (zonecfg.err != null)
        console.log("info ", zonecfg.stderr.toString());
    return zonecfg.stdout.toString();
}

function exec(zonename, cmd, out) {
    var zlogin = spawnSync('pfexec', ['zlogin', zonename, cmd]);

    if (zlogin.err != null)
        console.log("error executing ",cmd, zlogin.stderr.toString());

   if( out != undefined)
    out[cmd] = zlogin.stdout.toString();

    return zlogin.status;
}

function start(zonename) {

    var zone = getdata(zonename);
    if (zone == null) {
        console.log(chalk`{red.bold Error : alias does not exists}`);
        return null;
    }
    if (zone.state == "running")
     console.log(chalk`{blue.bold vm uuid ${zone.uuid} is already running}`);
 
    var start = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'boot']);

    if (start.error != null)
        console.log(chalk`{red.bold error starting region}`);
    console.log("starting ", start.stdout.toString(), start.stderr.toString());
    return start.status;
}

function rctl(zname, rctlobj) {
    var pid;
    var zone = getdata(zname);
    if (zone == null) {
        console.log(chalk`{red.bold Error : Alias does not exists}`);
        return null;
    }
    if (zone.state == "running") {
 
  	  var zinitpid = spawnSync('pgrep', [ '-z', zonename, 'init']);
	    if (start.error != null)
       		 console.log(chalk`{red.bold error getting updating zone resources }`);
	  pid = zinitpid.stdout.toString();  

	  Object.keys(rctlobj).forEach(function(key){ 
  	  var rctl = spawnSync('pfexec',['prctl', '-n',
		    `zone.${key}`, '-r', '-v',`${rctlobj[key]}`]);
	  console.log("rctl " , rctl.stdout.toString());
}
        );
	
   } else {
	  var script="";
	//TODO: call spec2script here 
	  Object.keys(rctlobj).forEach(function(key){
		   script += "add rctl; set name = zone." + key + ";" +
			     "add value (priv=privileged,limit= " + 
                             rctlobj[key] + ",action=deny ) ;end;"
		   });

  	  var zinitpid = spawnSync('pgrep', [ '-z', zonename, 'init']);
    }
    return start.status;
}


function halt(zonename) {
    var stop = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'halt']);
    if (stop.error != null)
        console.log("info ", stop.stdout.toString());

    return stop.stdout.toString();
}

function reboot(zonename) {
    var reboot = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'reboot']);
    if (reboot.error != null)
        console.log("info ", reboot.stdout.toString());

    return reboot.status;
}

function install(zonename) {
    var iz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'install']);
    if (iz.error != null) {
        console.log("Error installing ", iz.stderr.toString());
	}
    console.log(iz.stdout.toString());
    console.log(iz.stderr.toString());
    return iz.status;
}

function uninstall(zonename) {
    var uz = spawnSync('pfexec', ['zoneadm', '-z', zonename, 'uninstall']);
    if (uz.error != null)
        console.log("Error uninstalling ", uz.stderr.toString());

    return uz.status;
}

function addattr(zonename, zoneobj, attr) {
    var cmd, attr;
    if ("brand" in zoneobj) {
        cmd = 'add attr; set name=' + attr.name + ';' +
            'set type=' + attr.type + ';'
        'set value=' + attr.value + ';' + 'end';
        attr = spawnSync('zonecfg', ['-z', zonename, cmd]);
        if (attr.error != null)
            console.log("Error adding attribute:", attr.stderr.toString());
        return attr.status;
    } else {
        console.log("Error zoneobj does not have brand property");
        return null;
    }
}
//TODO: check if vnic is already taken, if that so zone creation will fail.

function create(zonename, zone_spec) {

    var script = spec2script(zonename, zone_spec);
    var status = -1;
    if (script != null) {
        var zonecfg = spawnSync('pfexec', ['zonecfg', '-z', zonename, script]);
	if (zonecfg.err != null) {
	   console.log("Error creating", zonecfg.stderr.toString());
	   return null;
	}
        status = install(zonename);
        if (status != 0) {
            console.log("Error: Installing zone", zonename);
        }
	status = setupzone(zonename, zone_spec);
        if (status != 0) {
            console.log("Zone postsetup failed= ", status);
            return status;
        }
    }
    return status;
}

function setupzone(zonename, zone_spec) {
    var status = -1;
    switch (zone_spec.brand) {
        case "sparse":
		status = start(zonename);
       		 if (status != 0) {
	            console.log("Error: Starting zone", zonename);
       		 }

            var setup = genpostscript(zone_spec);
            var status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            while (status != 0) {
                status = exec(zonename, "svcs svc:/milestone/multi-user | grep online");
            }

            status = exec(zonename, setup);
            if (status != 0)
                console.log("Error exec setting up zone", setup);
            status = halt(zonename);
            if (status != 0)
                console.log("Error halting setting up zone", setup);
            break;

        default:
            break;
    }
    return status;
}


function create_zone_spec(resources) {
    var spec = {
        zonepath: "",
        brand: "",
        'ip-type': "exclusive",
        'dns-domain': "",
        resolvers: ["8.8.8.8", "8.8.8.4"],
	autoboot: "false"
    };
    console.log("resources ", resources);
    if (resources != null && ("net", "brand" in resources)) {
        Object.keys(resources).forEach(function(key) {
            spec[key] = resources[key];
        });
    }
    return spec;
}

function spec2script(zname, spec) {
    var script = "";
    var zone = getdata(zname);
    if (zone != null) {
        console.log("Error : alias already exists");
        return null;
    }
    if ("brand", "net" in spec) {
        script = "create;"
        Object.keys(spec).forEach(function(key) {
            switch (key) {
             case "net":
                    spec.net.forEach(function(e) {
                        script +=
                            " add net ;";
                        if (spec.brand == "lx")
                            Object.keys(e).forEach(function(key) {
                                script += " set " + key + "=" + e[key] + ";";
                            });
                        else
                            script += " set physical=" + e["physical"] + ";";
                        script += " end;"
                    });
                    break;

              case "resolvers":
              case "dns-domain":
                    break;

              case "rctl":
		     if ( "dedicated-cpu" in spec.rctl) {
		 	script+="add dedicated-cpu;set ncpus=" + 
				spec.rctl["dedicated-cpu"] + ";"
				if ("importance" in spec.rctl){
			         "set importance=" + spec.rctl["importance"] +";" ;	
				}
			}

                    Object.keys(spec.rctl).forEach(function(key){
                    if (key == "max-physical-memory" || 
			key == "max-locked-memory" ||
			key == "max-swap" || 
			key == "max-lwps" ||
			key == "max-shm-ids" ||
			key == "max-msg-ids" ||
			key == "max-shm-memory") { 
		    script+= "add rctl;";
		   script += "set name=zone." + key + ";" +
			     "add value (priv=privileged,limit=" + 
                             spec.rctl[key] + ",action=deny);"

	        script +="end; ";
		} else if (key == "cpu-shares") {
		        script+= "set name=zone.cpu-shares;" +
				 "add value (priv=privileged, limit=" 
				+ spec.rctl["cpu-shares"] + ",action=none);"
			}		   
		});
                break;

                default:
                    script += " set " + key + "=" + spec[key] + ";";
                    break;
            }
        });
        script += "verify; commit;";
    } else {
        console.log("error not a valid spec");
        return null;
    }
    console.log("script ", script);
    return script
}

/*
 * This is needed to setup networking in sparse zones
 *  # zoneadm -z omni boot
 *  # zlogin omni
 *  # ipadm create-if omni0
 *  # ipadm create-addr -T static -a local=x.x.x.x/y omni0/v4
 *  # echo x.x.x.x > /etc/defaultrouter
 *  # echo nameserver 80.80.80.80 > /etc/resolv.conf
 *  # cp /etc/nsswitch.{dns,conf}
 *  # svcadm restart routing-setup
 */

function genpostscript(zone_spec) {
    var postshellcmd = "";
    switch (zone_spec.brand) {
        case "sparse":
            postshellcmd = "sleep 1; "
            zone_spec.net.forEach(function(e) {
                Object.keys(e).forEach(function(key) {
                    if (key == "physical") {
                        postshellcmd += "ipadm create-if " + e["physical"] + " && ";
                    }
                    if (key == "address") {
                        postshellcmd +=
                            "ipadm create-addr -T static -a local=" +
                            e["address"] +
                            " " +
                            e["physical"] + "/v4 && ";

                    }
                    if (key == "gateway") {
                        postshellcmd += " echo " + e[key] + " >> /etc/defaultrouter &&";
                    }
                });
            });

            var resolvers = zone_spec.resolvers.toString().split(",");
            for (var i = 0, len = resolvers.length; i < len; i++) {
                postshellcmd += " echo nameserver " + resolvers[i] + " >> /etc/resolv.conf &&";
            }
            postshellcmd += " cp /etc/nsswitch.{dns,conf} && svcadm restart routing-setup ";
            break;

        default:
            postshellcmd = null;
    }
    return postshellcmd;
}
/*
 *  Parses --ipaddr="vnic0|192.168.1.1/24|gateway,.."
 *  to a network json tag
 */
function ipaddrcmd2netobject(ipaddr) {
    var networks = ipaddr.split(",");
    var net = [];
    for (var i = 0, l = networks.length; i < l; i++) {
        var o = {};
        addrnic = networks[i].split("|");
        if (addrnic.length < 3) {
            console.log(chalk`{red.bold Error} not enough parameters in --net\n example : --net="vnic|vm-ipaddress|vm-gateway-ipaddress`);
	     return null;
        }
        o["physical"] = addrnic[0];
        var address = addrnic[1].split("/");
        o["address"] = address[0];
        if (ip.parse(o["address"]).kind() == "ipv4") {
            o["netmask"] = ip.IPv4.subnetMaskFromPrefixLength(address[1]).toString();
        } else {
            o["netmask"] = ip.IPv6.subnetMaskFromPrefixLength(address[1]).toString();
        }
        o["gateway"] = addrnic[2];
        net.push(o);
    }
    //console.log("network is ", net);
    return net;
}
// minimal zonespec
// https://docs.oracle.com/cd/E19044-01/sol.containers/817-1592/z.config.ov-13/index.html
// http://cuddletech.com/?p=314
//var o = {
//    brand: "sparse",
//    autoboot: "false",
//    zonepath: "/zones/test01",
//    net: [{
//        physical: "vnic0",
//        gateway: "192.168.1.1",
//        ips: ["192.168.1.108"],
//    }],
//   rctl: {
//            zone.max-physical-memory: "2gb",
//	      zone.max-locked-memory: "2gb",
//	      zone.max-swap: "2gb",
//	      zone.max-shm-ids: "",
//            zone.max-msg-ids: "",
//            zone.max-lwps: "",
//            zone.cpu-shares: "",
//            zone.max-shm-memory:"",
//            dedicated-cpu:"1-2",
//	      importance:"1"
//         }
//};

function build(createOptions) {

	if (!!createOptions['dedicated-cpu'] &&  !!createOptions['cpu-shares']) {
	    console.log(chalk`{red.bold Error} cpu-shares option is not compatible with dedicated-cpu option`);
	    return null;
	}
        if ("net" in createOptions) {
            var zname;
            createOptions["net"] =
                ipaddrcmd2netobject(createOptions["net"]);
	   if(createOptions["net"] == null ) {
            console.log(chalk`{red.bold Error} missing --net=nic|ipaddr`);
		return null;
		}
            if ("alias" in createOptions) {
                zname = createOptions["alias"];
                delete createOptions["alias"];
            } else {
                zname = uuidv4();
            }
            createOptions["zonepath"] = `/zones/${zname}`;
            var count = createOptions["count"];
            delete createOptions["count"];

	    if ("dram"  in createOptions) {
           	 createOptions["rctl"] = addrctl(createOptions); 
            }

	    delete createOptions["dram"];
            delete createOptions["dedicated-cpu-importance"];
            delete createOptions["dedicated-cpu"];

            var z = create_zone_spec(createOptions);
            if (create(zname, z) == 0) {
                console.log("VM created: ", zname);
            } else {
                console.log("Failed creating VM : ", zname);
		}
        } else {
            console.log(chalk`{red.bold Error} missing --net=nic|ipaddr`);
	    return null;
        }
}

function addrctl(createOptions ) {
	console.log("Entering addrctl");
        let rctl = {};
	let obj = {};
               if ("cpu-shares" in createOptions) {
		rctl['cpu-shares'] = createOptions['cpu-shares'];
		obj['cpu-shares'] = rctl['cpu-shares'];
	}
	 if ("dram" in createOptions) {
        	rctl.dram = createOptions.dram;
		obj['max-physical-memory'] = bytes.parse(rctl.dram).toString(); 
		obj['max-locked-memory'] = bytes.parse(rctl.dram).toString(); 
		obj['max-swap'] = bytes.parse(rctl.dram).toString(); 
      }
       if ("dedicated-cpu" in createOptions) {
	    obj['dedicated-cpu'] = createOptions['dedicated-cpu']; 
	    obj['importance'] =  createOptions['dedicated-cpu-importance'];
       }
	if ("max-lwps" in createOptions) {
	    obj['max-lwps'] =  createOptions['max-lwps'];
  	}	
        console.log("rctl obj ", obj);
  return obj;
}

module.exports.destroy = destroy;
module.exports.create = create;
module.exports.halt = halt;
module.exports.start = start;
module.exports.listzones = listzones;
module.exports.build = build;
module.exports.create_zone_spec = create_zone_spec;
module.exports.ipaddrcmd2netobject = ipaddrcmd2netobject;
